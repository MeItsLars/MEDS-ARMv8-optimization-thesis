
* page 44: It's tricky to include loads and stores in the lower bound beyond
  loading inputs once at the beginning and storing outputs once at the end.
  Who tells you that you need to go to and from memory every time between
  loops...

* I'm pretty certain that it's possible to come up with a program where
  the CPU is not able to schedule instructions optimally on the fly.
  I'm happy with using the word "optimized", but my intuition is that the
  "optimal" in the reference manual is just marketing BS.

* "by running that function 128 times and taking the minimum of the timing
  results": the standard approach is to use the median (and ideally also
  report quartiles).

* "and therefore provides a different level of confidence in the
  security of the scheme": I think most people would have lower confidence in
  MEDS than in Dilithium or Falcon, so that argument doesn't quite work. It's
  more of the idea that you want to study other options in case that lattice
  problems turn out to be easier than we currently think they are.

  (you say this at two different spots)

  
-------------------------
STUFF
-------------------------

>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ASM
// w0 = input
// w8 = N' = 2731
// w9 = MEDS_p = 4093

// w8 = input * N'
mul     w8, w0, w8
// w8 = (input * N') & Rmask = (input * N') & 0xFFF
and     w8, w8, #0xfff
// w8 = ((input * N') & Rmask) * MEDS_p + input
madd    w8, w8, w9, w0
// w0 = ((input * N') & Rmask) * MEDS_p + input) >> 12
lsr     w0, w8, #12
ret

// ---------------------------------------------------------------------

mov     w8, #2731                       // w8 = N' = 2731
ldr     q1, [x0]                        // v1.4s = input
movi    v2.4s, #15, msl #8              // v2.4s = 15 << 8 with lower bits 1 = 0xFFF = Rmask
dup     v0.4s, w8                       // v0.4s = N'
mov     w8, #4093                       // w8 = MEDS_p = 4093
dup     v3.4h, w8                       // v3.4h = MEDS_p

mul     v0.4s, v1.4s, v0.4s             // v0.4s = input * N'
and     v0.16b, v0.16b, v2.16b          // v0.4s = (input * N') & Rmask = (input * N') & 0xFFF
xtn     v0.4h, v0.4s                    // v0.4h = v0.4s (narrowed to 16-bit)
umlal   v1.4s, v0.4h, v3.4h             // v1.4s = ((input * N') & Rmask) * MEDS_p + input
ushr    v0.4s, v1.4s, #12               // v0.4s = ((input * N') & Rmask) * MEDS_p + input) >> 12
xtn     v0.4h, v0.4s

>>>>>>>>>>>>>>>>>>>>>>>>>>>>> PYTHON
# Author: Project Nayuki
# (Public domain)
# Source: https://www.nayuki.io/page/montgomery-reduction-algorithm
def multiplicative_inverse(x, mod):
  # Based on a simplification of the extended Euclidean algorithm
  assert mod > 0 and 0 <= x < mod
  y = x
  x = mod
  a = 0
  b = 1
  while y != 0:
    a, b = b, a - x // y * b
    x, y = y, x % y
  if x == 1:
    return a % mod
  else:
    raise ValueError("Reciprocal does not exist")

N = 4093
R = 1 << 12
Rmask = R - 1
Rinv = multiplicative_inverse(R % N, N)
Nprime = (R * Rinv - 1) // N

print("N", N)
print("R", R)
print("Rmask", Rmask)
print("Rinv", Rinv)
print("Nprime", Nprime)
print()

def to_montgomery(x):
    return (x << 12) % N

def montgomery_redc(w0):
    w8 = 2731
    w9 = 4093
    w8 = w0 * w8
    w8 = w8 & 0xFFF
    w8 = w0 + w8 * w9
    w0 = w8 >> 12
    return w0

def montgomery_redc2(t):
    temp = ((t & Rmask) * Nprime) & Rmask
    reduced = (t + temp * N) >> 12
    result = reduced if (reduced < N) else (reduced - N)
    return reduced

def from_montgomery(x):
    return montgomery_redc2(x)
    
def montgomery_mult(a, b):
    return montgomery_redc(a * b)
    
A = 2 << 29
B = 1

print((A * B) % N)
print(from_montgomery(montgomery_mult(to_montgomery(A * B), to_montgomery(1))))

>>>>>>>>>>>>>>>>>>>>>>>>>>>>> C

#include <stdint.h>

#define MEDS_p 4093

#define MG_R_bits 12
#define MG_R 4096 // (1 << MG_R_bits)
#define MG_Rmask 4095 // (MG_R - 1)
#define MG_R_inv 2729
#define MG_Nprime 2731 // floor(((MG_R * MG_R_inv) - 1) / N)

uint32_t montgomery_redc(uint32_t t)
{
  uint32_t m = ((t & MG_Rmask) * MG_Nprime) & MG_Rmask;
  uint32_t res = (t + m * MEDS_p) >> MG_R_bits;
//   res = res > MEDS_p ? res - MEDS_p : res;
  return res;
//   int32_t diff = res - MEDS_p;
//   int32_t mask = (diff >> 31) & 0x1;
//   return mask * res + (1 - mask) * diff;
}

uint32_t* test(uint32_t *input) {
    for (int i = 0; i < 4; i++) {
        uint32_t t = input[i];
        uint32_t m = ((t & MG_Rmask) * MG_Nprime) & MG_Rmask;
        uint32_t res = (t + m * MEDS_p) >> MG_R_bits;
        input[i] = res;
    }
    return input;
}